package Gen_div_by_const_fn;
require Exporter;

# This module provides a perl function 'gen_div_by_const_fn'
# that generates a verilog function (e.g. 'div_by_3_fn')
# that implements division by a constant.
#
# The code generated by this module synthesizes better than 
# raw verilog code like :
# ' assign q = x/3; '
#

our @ISA = qw(Exporter);
our @EXPORT = qw(gen_div_by_const_fn);
our $VERSION = 1.00;

sub clog2 {
  my ($n) = @_;
  my $l = int( (log($n)/log(2)) + 0.99999 );
  return $l;
}

sub gen_div_by_const_fn{
  my ($N, $ibits, $obits, $fname) = @_;
  # N = constant to divide by.
  # ibits = input bits (default = 32)
  # obits = output quotient bits (optional)
  # fname = function name (optional).

  die "N must be defined. N=$N." unless (defined $N);
  $ibits //= 32;
  $obits //= &clog2( 1.0*(2**$ibits)/$N );
  $fname //= "div_by_${N}_fn";

  my $ibits_m1 = $ibits - 1;
  my $obits_m1 = $obits - 1;

  # Factorize N into power of 2 (wizard) and non-power of 2(muggle).
  my $Nw = 1;
  while (($N % ($Nw * 2)) == 0) { $Nw *= 2; }
  my $Nm = $N/$Nw;

  my $lN = clog2($N);
  my $lNw = clog2($Nw);
  my $lNm = clog2($Nm);
  my $lN_m1 = $lN - 1;
  my $lNw_m1 = $lNw - 1;
  my $lNm_m1 = $lNm - 1;

  # Header
  my $return_type = "div_result_${ibits}_${N}_t";
  my $output = "";
  $output .= <<XYZ;
  typedef struct packed {
    logic [${obits_m1}:0] \t q; // quotient
    logic [${lN_m1}:0] \t r; // remainder
  } $return_type;

  function $return_type $fname ( logic [${ibits_m1}:0] x );
   $return_type result;
   logic [${ibits_m1}:0] \t wq;
XYZ
  $output .= <<XYZ if ($lNw > 0);
   logic [${lNw_m1}:0] \t wr;
XYZ

  # Declarations
  my ($piece_sz, $num_pieces);
  $piece_sz = $lNm + 2;
  $num_pieces = 1;
  $num_pieces *= 2 while ($num_pieces * $piece_sz < $ibits);

  my ($np, $ps, $i) = ($num_pieces, $piece_sz, 0);
  while ($np >= 1) {
    my $np_m1 = $np - 1;
    my $ps_m1 = $ps - 1;
    $output .= <<XYZ;
   logic [$np_m1:0][${ps_m1}:0] \t q_${i};
XYZ
    if ($i > 1) {
      $output .= <<XYZ;
   logic [$np_m1:0][${ps_m1}:0] \t aq_${i};
XYZ
    }
    if ($i > 0) {
      $output .= <<XYZ;
   logic [$np_m1:0][${lNm_m1}:0] \t r_${i};
XYZ
      $np /= 2; $ps *= 2; 
    }
    $i++;
  }

  # End header
  $output .= <<XYZ;
  begin

XYZ

  if ($Nw > 1) {
  $output .= <<XYZ;
    // Handle the power of 2 part first.
    wq = x[$ibits_m1:$lNw];
    wr = x[$lNw_m1:0];
XYZ
  } else {
  $output .= <<XYZ;
    wq = x;
XYZ
  }

  if ($Nm > 1) {
    # Calculate first layer : divide each piece by $N.
    $output .= <<XYZ;

    // Now work on the hard part : non-power of 2.
    // Separate input into $num_pieces pieces of size $piece_sz bits each.
    q_0 = wq;

    // Divide each piece by $Nm 
    q_1 = 0; r_1 = 0;
    for (int i = 0; i < $num_pieces; i++) begin
      case(q_0[i])
XYZ
    foreach $i (1 .. (2**$piece_sz - 1)) {
      my $i_div_Nm = int ($i / $Nm);
      my $i_mod_Nm = $i % $Nm;
      $output .= <<XYZ;
        $i : begin q_1[i] = $i_div_Nm; r_1[i] = $i_mod_Nm; end
XYZ
    }
    $output .= <<XYZ;
      endcase
    end

XYZ

    # Refine result as many times as needed.
    my ($np, $ps, $j) = ($num_pieces, $piece_sz, 1);
    while ($np > 1) {
      $np /= 2; $ps *= 2; $j++;
      my $k = $j - 1;
      $output .= <<XYZ;
    // Refine result for each pair of pieces
    for (int i = 0; i < $np; i++) begin
      case({r_${k}[2*i+:2]})
XYZ
      foreach my $rem1 (1 .. ($Nm - 1)) {
        foreach my $rem2 (0 .. ($Nm - 1)) {
          my $total_rem = ($rem1 << ($ps/2)) + $rem2;
          my $total_rem_div_Nm = int($total_rem / $Nm);
          my $total_rem_mod_Nm = $total_rem % $Nm;
          $output .= <<XYZ;
        {${lNm}'d${rem1}, ${lNm}'d${rem2}} : begin aq_${j}[i] = $total_rem_div_Nm; r_${j}[i] = $total_rem_mod_Nm; end // rem = $total_rem = $total_rem_div_Nm * $Nm + $total_rem_mod_Nm
XYZ
        }
      }
      $output .= <<XYZ;
        default      : begin aq_${j}[i] = 0; r_${j}[i] = r_${k}[2*i]; end
      endcase
      q_${j}[i] = q_${k}[2*i+:2] + aq_${j}[i];
    end

XYZ
    }

    # Final hookup.
    $output .= <<XYZ;
    result.q = q_${j}[0];
XYZ
    if ($Nw > 1) {
      $output .= <<XYZ;
    result.r = r_${j}[0] << $lNw + wr;
XYZ
    } else {
      $output .= <<XYZ;
    result.r = r_${j}[0];
XYZ
    }
  } else {
    $output .= <<XYZ;

    result.q = wq;
    result.r = wr;
XYZ
  }

  # Footer
  $output .= <<XYZ;
    return result;
  end
  endfunction
XYZ

  return $output;
}

1;

